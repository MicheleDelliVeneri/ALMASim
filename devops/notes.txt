Number of WCS axes: 4
CTYPE : 'RA---TAN'  'DEC--TAN'  'VOPT'  'STOKES'  
CRVAL : 0.0  0.0  2032200.0  0.0  
CRPIX : 64.5  64.5  32.0  0.0  
PC1_1 PC1_2 PC1_3 PC1_4  : 1.0  0.0  0.0  0.0  
PC2_1 PC2_2 PC2_3 PC2_4  : 0.0  1.0  0.0  0.0  
PC3_1 PC3_2 PC3_3 PC3_4  : 0.0  0.0  1.0  0.0  
PC4_1 PC4_2 PC4_3 PC4_4  : 0.0  0.0  0.0  1.0  
CDELT : -0.0027777777777778  0.0027777777777778  40000.0  1.0  
NAXIS : 128  128  64  1


NAXIS sono n_pix_x, n_pix_y e n_channels
cdelt 


1. Create the maartini datacube for gaussians
2. generate properties vector out of make cube

### MARTINI DATA CUBE

https://martini.readthedocs.io/en/latest/_modules/martini/datacube.html#DataCube


datacube_unit = U.Jy * U.pix**-2
        self._array = np.zeros((n_px_x, n_px_y, n_channels, 1)) * datacube_unit
        self.n_px_x, self.n_px_y, self.n_channels = n_px_x, n_px_y, n_channels
        self.px_size = px_size
        self.channel_width = channel_width
        self.velocity_centre = velocity_centre
        self.ra = ra
        self.dec = dec
        self.padx = 0
        self.pady = 0
        self.wcs = wcs.WCS(naxis=3)
        self.wcs.wcs.crpix = [
            self.n_px_x / 2.0 + 0.5,
            self.n_px_y / 2.0 + 0.5,
            self.n_channels // 2,
        ]
        self.units = [U.deg, U.deg, U.m * U.s**-1]
        self.wcs.wcs.cunit = [unit.to_string("fits") for unit in self.units]
        self.wcs.wcs.cdelt = [
            -self.px_size.to(self.units[0]).value,
            self.px_size.to(self.units[1]).value,
            self.channel_width.to(self.units[2]).value,
        ]
        self.wcs.wcs.crval = [
            self.ra.to(self.units[0]).value,
            self.dec.to(self.units[1]).value,
            self.velocity_centre.to(self.units[2]).value,
        ]
        self.wcs.wcs.ctype = ["RA---TAN", "DEC--TAN", "VELO-OBS"]
        self.wcs = wcs.utils.add_stokes_axis_to_wcs(
            self.wcs, self.wcs.wcs.naxis
        )
        self._channel_mids()
        self._channel_edges()
        self._freq_channel_mode = False



collections,
o_ucd,
obs_publisher_did,
obs_collection,
facility_name,
instrument_name,
obs_id,dataproduct_type,
calib_level,target_name,
s_ra,
s_dec,
s_fov,
s_region,
s_xel1,
s_xel2,
em_xel,
t_xel,
pol_xel,
s_resolution,           *** spatial resolution
t_min,
t_max,
t_exptime,              *** integration time
t_resolution,
em_min,                 *** note, this is in meters (!)
em_max,                 *** note, this is in meters (!)
em_res_power,
pol_states,
access_url,
access_format,
access_estsize,
proposal_id,
data_rights,
gal_longitude,
gal_latitude,
band_list,
em_resolution,          *** frequency resolution
bandwidth,              ***
antenna_arrays,
is_mosaic,
obs_release_date,
spatial_resolution,     *** spatial resolution (arcsec)
frequency_support,
frequency,              ***
velocity_resolution,    ***
obs_creator_name,
pub_title,
first_author,
authors,
pub_abstract,
publication_year,
proposal_abstract,
schedblock_name,
proposal_authors,
sensitivity_10kms,      *** estimated(!) sensitivity at 10km/s resolution
cont_sensitivity_bandwidth, *** estimated continuum sensitivity
pwv,group_ous_uid,
member_ous_uid,
asdm_uid,
obs_title,
type,
scan_intent,            *** to distinguish between science targets and calibration targets
science_observation,
spatial_scale_max,
qa2_passed,
bib_reference,
science_keyword,
scientific_category,
lastModified